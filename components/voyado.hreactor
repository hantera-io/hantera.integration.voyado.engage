let baseUrl |> registry->'externalServices/voyado/baseUrl'
let apiKey |> registry->'externalServices/voyado/apiKey'

let findContact(email: text) =>
  web.http(
    $'{baseUrl}/api/v3/contacts/id?email={email}'
    {
      headers = {
        'User-Agent' -> 'Hantera'
        'apikey' -> $'{apiKey}'
        'Content-Type' -> 'application/json'
      }
    }
   ) match
    (res: HttpResponseOk) |> res.content

let getOrder(orderId: uuid) =>
  // Get current order state
  let orderQuery =
    query orders(orderState, currencyCode, invoiceAddress)
    filter $'orderId == {orderId}'
    navigate
      deliveries(
        deliveryId
        deliveryNumber
        createdAt
        deliveryState
        shippingTotal
        shippingPrice
        shippingTaxFactor
        shippingTaxTotal
      )
      navigate
        orderLines(
          productNumber
          description
          orderLineTotal
          quantity
          image
          taxTotal
          taxFactor
        )
        navigate calculatedDiscounts(value)
    navigate
      paymentCaptures(amount)
      navigate payment(providerKey)
  
  // Extract order state from query result
  from orderQuery match
    QueryError |> nothing
    |>
      orderQuery
      first

let defaultOrderMap(contactId, order, delivery) =>

  let orderStatus = order.orderState match
    'cancelled' |> 'Cancelled'
    'confirmed' |> delivery.deliveryState match
      'completed' |> 'Shipped'
      'cancelled' |> 'Cancelled'
      |> 'Confirmed'
    'completed' |> 'Shipped'
  
  let paymentMethods =
    order.paymentCaptures
    select (c: {
      amount: number
      payment: {
        providerKey: text
      }
    }) => {
      description = c.payment.providerKey
      value = c.amount
    }

  let orderLines =
    delivery.orderLines
    select line =>
      let totalDiscounts =
        line.calculatedDiscounts
        select d => d.value
        sum

      from {
        type = 'Purchase'
        sku = line.productNumber
        quantity = line.quantity
        grossPaidPrice = line.orderLineTotal
        grossPaidPricePerUnit = line.orderLineTotal / line.quantity
        originalPricePerUnit = (line.orderLineTotal + totalDiscounts) / line.quantity
        description = line.description match
          nothing |> 'Product'
          (d: text) |> d
        imageUrl = line.image
        // TODO targetUrl = 
        taxAmount = line.taxTotal
        taxPercent = line.taxFactor * 100
        totalDiscount = totalDiscounts
        extraData = { }
      }

  let shippingLines = [{
    type = 'Purchase'
    sku = 'Shipping'
    description = 'Shipping'
    quantity = 1
    grossPaidPrice = delivery.shippingTotal
    grossPaidPricePerUnit = delivery.shippingTotal
    originalPricePerUnit = delivery.shippingPrice
    totalDiscount = delivery.shippingPrice - delivery.shippingTotal
    taxAmount = delivery.shippingTaxTotal
    taxPercent = delivery.shippingTaxFactor * 100
  }]

  let items = [orderLines, shippingLines] flatten

  from {
    contact = {
      matchKeyType = 'ContactId'
      matchKey = contactId
    }
    orderNumber = delivery.deliveryNumber
    orderStatus = orderStatus
    paymentStatus = 'Paid'
    createdDate = delivery.createdAt
    // TODO shippedDate = 
    // TODO: 
    storeId = 'eCom-Sverige'
    currency = order.currencyCode
    paymentMethods = paymentMethods
    items = items
  }

let withTotalGrossPrice (voyadoOrder) |>
  voyadoOrder with {
    totalGrossPrice =
      voyadoOrder.items
      select (i: {
        grossPaidPrice: number
      }) => i.grossPaidPrice
      sum
  }

from {
  createOrUpdateOrder = (orderId: uuid) =>

    let order = getOrder(orderId)

    let mapOrder (contactId, order, delivery) =>
      defaultOrderMap(contactId, order, delivery)

    from order match
      nothing |> 'Order not found'
      when order.orderState == 'pending' |> 'Can not export pending order'
      when (order.deliveries count) == 0 |> 'No deliveries on order'
      |> findContact(order.invoiceAddress.email) match
        (contactId: text) |>
          order.deliveries
          select d =>
            web.http(
              $'{baseUrl}/api/v2/orders'
              {
                method = 'POST'
                headers = {
                  'User-Agent' -> 'Hantera'
                  'apikey' -> $'{apiKey}'
                  'Content-Type' -> 'application/json'
                }
                body = mapOrder(contactId, order, d) withTotalGrossPrice
              }
            ) match
              HttpResponseOk |> $'Exported delivery {d.deliveryNumber}'
              (res: HttpResponse) |> $'Failed to export delivery {d.deliveryNumber}: ({res.content})'
        |> 'Contact not found'

}
